# """This script splits out different observations in a single measurement set based on 
# name of the fields observed.  Additionally, spectral windows are split if they 
# correspond to different frequency resolutions (continuum data versus line observations). """

## This is now a 2-part script which supercedes the original splitobs.py .  
## This is part 1, which uses the msmd tools (only available in
## more recent versions of CASA) to identify the appropriate components for the splitting.
## Part 2 actually runs the splitting, and must be run in the same version of CASA as was
## originally used for the calibration in scriptForPI.py
## (Part 1 should be able to be run in any version of CASA later than 4.2.2pipe, which was
## the first(?) version to include the msmd tools)

import numpy as np
import glob
from os import path

# This script should be run after running scriptForPI.py to generate calibrated 
# measurement sets.



####################### Start of the script #####################

# Part 1: Identify all of the files which have had measurement sets generated for them
# assume a file name format of [uid...].ms.split.cal
# NB for CADC: the set of calibrated measurement sets generated by scriptForPI may be a 
# smaller list than the total number of raw datasets, if some raw datasets failed QA


# Read in the list of calibrated measurement sets one-by-one, pull out target names & info for splitting


def split_ms_name(filename):
    """
    Identify all components to be split
    """
    print("Identify components for splitting in {}".format(filename))
    msmd.open(filename)
    ms_name = filename.rstrip("ms.split.cal")

    # 1) Create a list of all target names for science & calibrator sources.
    #   Note that all science fields have the observing intent 'OBSERVE_TARGET'
    #   All calibrator fields have observing intents of 'CALIBRATE*', however,
    #   sometimes the science fields also have these observing intents
    #   included (e.g., CALIBRATE_WVR)  

    # Identify science fields
    # Note that sometimes have multiple field numbers for the same field name
    sci_field_names = list(np.unique(msmd.fieldsforintent("OBSERVE_TARGET*",True)))

    #(New for the 2-part version: Write out this list)
    with open(ms_name+'_scifields.txt', 'w') as f:
        for item in sci_field_names:
            f.write("%s\n" % item)

    # Get list of all fields (likely msmd.fields could provide a complete list but
    # here we take the calibrate list and append the science target list)
    field_names = list(np.unique(msmd.fieldsforintent('CALIBRATE*',True)))
    field_names.extend(sci_field_names)
    field_names = np.unique(np.array(field_names))

    #(New for the 2-part version: Write out this list)
    with open(ms_name+'_allfields.txt','w') as f:
        for item in field_names:
            f.write("%s\n" % item)


    # remove the attachment to the msmd object.
    # HK added the comment sign below (Aug20/19).  Need to be able to still access the metadata when looping
    # on the individual field names for the Nchan determination below
    # msmd.done()

    # Loop through each of these fields and split out measurement set    
    for field_name in field_names:
        # HK added (Aug20/19): determine the number of channels per spectral window.
        # If Nchan is 128, that spectral window is in TDM/continuum mode. 
        # Nchan > 128 implies a spectral line observation (FDM mode).
        # We want to keep all 'spw's with Nchan=128 as a single entity, and separate 
        # each spw with Nchan>128 as an independent file
        spws_field = list(np.unique(msmd.spwsforfield(field_name))) #this gives the spw #s for this field name
        # Get the number of channels in each of these spectral windows & classify
        cont_spws=[]
        line_spws=[]
        for spws in spws_field:
            spws_Nchan = msmd.nchan(spws)
            #if 128, add spw to continuum array, otherwise, to line array
            if spws_Nchan == 128:
                cont_spws.append(spws)
            else:
                line_spws.append(spws)
        #print("continuum spws")
        #print(cont_spws)

        #print("line spws")
        #print(line_spws)
        #end of HK additions

        #Write these out to file (if exist)
        if cont_spws:
            with open(ms_name+'_'+field_name+'_contspws.txt','w') as f:
                for item in cont_spws:
                    f.write("%s\n" % item)
        if line_spws:
            with open(ms_name+'_'+field_name+'_linespws.txt','w') as f:
                for item in line_spws:
                    f.write("%s\n" % item)



msmd.done()  #HK added -- this line is moved from above, as it is now used a little later in the code 

if __name__ == "__main__":
    BASE_FILENAME = "*.ms.split.cal" # Types of files to process
    for filename in glob.glob(BASE_FILENAME):
        split_ms_name(filename)

